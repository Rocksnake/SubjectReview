## 存储器、CPU

> From 看雪学院

|            | 速度           | 成本   |
| ---------- | -------------- | ------ |
| 外部存储器 | 读写速度比较慢 | 300/T  |
| 内部存储器 | 比较快         | 300/4G |

内部存储器分为RAM（随机存储器），ROM（只读存储器），区别在于断电数据是否消失，ROM不会消失，而RAM会消失。

存储单元，每个单元由存储单元的地以及存储单元的内容构成，均为16进制。

CPU对存储器的读写是通过三种总线完成。

![image.png](https://i.loli.net/2020/07/18/EyLhi5bVZmsAY8t.png)

* 地址总线的宽度决定了CPU的寻址能力；
* 数据总线的宽度决定了CPU与其他器件进行数据传送的一次数据传送量；
* 控制总线宽度决定了CPU对系统中其他器件的控制能力。

一个CPU有N根地址总线，则可以说这个CPU的地址总线的宽度为N，最多可以寻找$2^N$个内存单元。8086有20根地址线。

一根数据总线可以传输一个0或1,8086的数据总线宽度分别为16根。一次可以传送的数据为2B

## 寄存器

> 程序需要加载到内存中，CPU通过寄存器(CS: IP)寻址来确定即将执行指令位置

### 介绍

并列于运算器和控制器，容量有限速度快，可以用来暂时存储指令、数据和地址，由于存在于CPU中，所以数量有限。

8086有14个寄存器，所有寄存器都是16位的，可以存放两个字节，即存放一个字。

### 组成

16位CPU所含有的寄存器有14个：

* **4个数据寄存器 AX、BX、CX、DX**
* **2个变址寄存器SI、DI和两个指针寄存器SP、BP**
* **4个段寄存器ES、CS、SS、DS**
* **一个指令指针寄存器IP和1个标志寄存器Flags**

32位的CPU比14位的多了两个寄存器，是段寄存器FS、GS，另外对于两种CPU中寄存器的区别就是32位的开头加一个E，除了段寄存器。

![image.png](https://i.loli.net/2020/07/18/EfTI7HLMOU4PGmV.png)

64位的前面加的是R

![image.png](https://i.loli.net/2020/07/18/j6ZEe4iLuzG78tl.png)

* 通用寄存器包括8个寄存器，数据寄存器的全部，变址寄存器和指针寄存器的全部

* 只有数据寄存器可以向下兼容，32位的分出来16位的，16位的分出来8位的

### 功能（分开介绍）

#### 通用寄存#器

可以用来传送和暂存数据，可参与算术逻辑运算并保存运算结果

#### 数据寄存器

* 保存操作数和运算结果
* 每一个数据寄存器都可以当做两个单独的寄存器使用

|    寄存器    |                             说明                             |
| :----------: | :----------------------------------------------------------: |
| AX（AL、AH） |               累加寄存器，用于乘除输入输出操作               |
| BX（BL、BH） |               基地址寄存器，作为存储器指针使用               |
| CX（CL、CH） | 计数寄存器，在<font color="red">循环</font>和字符串操作中，要用它来控制循环次数，在位操作中，当移多位时，要用CL指明移位的位数 |
| DX（DL、DH） | 数据寄存器，进行乘除运算时，可作为默认的操作数参与运算，也可用于I/O的端口地址 |

![image.png](https://i.loli.net/2020/07/18/dUD4T1m3AeYhCSr.png)

<font color="red">在16位CPU中，AX、BX、CX、DX不能存放存储单元的地址，32位寄存器中不仅可以传送数据、暂存数据保存算术逻辑运算结果，而且可以作为指针寄存器</font>

**For Example：**

MOV AX,11F6H  ->  11存入AH、F6存入AL

MOV  AL,0AH    ->   F6 + 0A = 100H, 9位，超过AL，所以去掉最高位，变成00H

### CS: IP

任意时刻，CPU将CS: IP指向的内容作为即将执行的指令

#### 物理地址

通常文件包含两个段，代码段和地址段

* 代码段可读、不可写、可执行，存储程序的指令
* 数据段可读、可写、可执行，存储程序中要用到的数据

运行一段代码时，首先将代码段加入到内存中，CPU找到代码段需要物理地址。

> 物理地址 = 基础地址 + 偏移地址
>
> 基础地址 = 段地址 x 10H

![image.png](https://i.loli.net/2020/07/18/fvZW6ozJOSnhYa5.png)

<font color="red">物理地址可以由不同的段地址和偏移地址形成</font>

**8086中有4个段寄存器：**

* CS代码段 【主要关注】
* DS数据段
* SS栈段
* ES附加段

#### 过程

1. CS、IP加入地址加法器，进行相加转换为20位的地址
2. 通过地址总线输入到内存当中，找到该地址的数据，并加载到数据总线当中，传入CPU
3. 到了 指令缓存器中
4. 由于执行了内存中的三条指令，所以IP + 3
5. 将结果存放在AX寄存器中

#### 修改CS：IP

CPU是由CS：IP中的内容决定执行命令

修改：

* 同时修改CS：IP内容
  * jmp 段地址：偏移地址
  * For Example：jmp 2AE3:3 -> 从2AE33H处读取指令
  * jmp 3:0B16  - > 从00B46H处读取指令
* 修改IP的内容
  * jmp 某一合法寄存器
  * For Example：jmp bx;
    * 执行前：bx = 0B16H, CS = 2000H, IP = 0003H
    * 执行后：bx = 0B16H, CS = 2000H, IP = 0B16H

## 分段管理及标志寄存器

![image.png](https://i.loli.net/2020/07/18/blmH4hNZ1LV6Yie.png)

### 分段管理

在8086中，一个存储单元对应一个物理地址，还有多个逻辑地址。

* 物理地址

  * 一个存储单元的编号，

  * 每个物理存储单元都有一个20位的编号（地址总线20条），
  * 物理地址范围00000H~FFFFFH（$2^{20}$ = 1M）<font color="red">4个二进制位可以构成16进制位</font>

* 逻辑地址

  * 编程时采用逻辑地址，段基地址：段内偏移地址

* 物理地址就是将逻辑地址左移4位，加上偏移地址就得到20位物理地址（物理 = 段基 + 偏移）【移4位，十进制数16的16进制为10H】

![image.png](https://i.loli.net/2020/07/18/xYpcNAq8tr3Qj14.png)

#### 段寄存器与逻辑段

8086CPU有4个段寄存器，**每个段寄存器用来确定一个逻辑段的起始位置**：

* CS 指明代码的起始地址
  * 利用CS：IP取得下一条要执行的指令
* SS 指明堆栈段的起始地址
  * 利用SS：SP操作堆栈顶的数据
* DS 指明数据的起始地址
  * 利用DS：EA存取数据段中的数据
* ES 指明附加段的起始地址
  * 利用ES：EA存取附加段中的数据

EA是偏移地址，称为有效地址EA

**若操作数在主存中，存取方法有直接寻址、寄存器间接寻址、寄存器相对寻址、基址变址寻址方式、相对基址变址寻址方式**

没有指明段前缀时，一般的数据访问在DS（数据段）

ForExample：

```汇编
	MOV AX,[1000H]; = MOV AX,DS:[1000H];

​	从默认的DS段中取出数据DS代表段基地址；[ ？] 代表偏移地址

​	MOV AX,CS:[1000H]

​	从指定CS段取出数据
```

如果没有指明段基地址，就要使用 DS 默认段基地址

### 标志寄存器

![image.png](https://i.loli.net/2020/07/19/lD4YFLRyo9dSaPi.png)

* 8086CPU有9个有效标志

| 标志位 | 标志位名称 |   =1   |    =0    |
| :----: | :--------: | :----: | :------: |
|   CF   |  进位标志  |  进位  |  无进位  |
|   PF   |  奇偶标志  |   偶   |    奇    |
|   AF   |  辅助进位  |  进位  |  无进位  |
|   ZF   |   零标志   | 等于零 | 不等于零 |
|   SF   |  符号标志  |   负   |   非负   |
|   TF   |  跟踪标志  |        |          |
|   IF   |  中断标志  |  允许  |   禁止   |
|   DF   |  方向标志  |  减少  |   增加   |
|   OF   |  溢出标志  |  溢出  |  未溢出  |

标志位可以分为

* 状态标志**【用于记录程序运行结果的状态信息】**
  * CF ZF SF PF OF AF
* 控制标志【**用于控制处理器执行指令**】
  * DF  IF TF

#### 进位标志CF

> 当运算结果的最高有效位有进位（加法）或借位（减法）时，进位标志置1，CF= 1；否则 =0

如：2C +7C = A8, 没有进位，CF= 0；没有超出8个字节，还在一个字当中

C2 + C7 = (1)89 有进位，CF = 1

#### 零标志ZF

> 若运算结果为 0 ，则ZF= 1

与运算结果相反，

**注意：**结果看的是单个字节当中，所以像之前的计算，有进位变成100，但是在8位中都为 0 ，所以按照结果为 0

#### 符号标志SF

> 若运算结果最高位为1，则SF=1

有符号运算，最高位代表符号

注：有符号范围：-128~127

---

计算机在存储数据时，是以补码形式存在的

---

同样还是在一个字节中看结果，即使进位了，也只看八位中的最高位，因为超出了有符号数的范围，由正值变成负值

#### 奇偶标志

> 若运算结果最低字节中“1”的个数为零或偶数时，PF= 1

#### 溢出标志

> 若运算结果有溢出，则OF = 1

如果运算结果超出了范围，就产生了溢出，有溢出，说明有符号数的运算结果不正确

**说明：**我们通常认为溢出就是因为进位时当前存储格式的位数不够引起，比如8位寄存器：11111111B + 1B = 100000000B。超过了8位的1被认为是溢出寄存器（放不下），当然也是进位的那个1

#### 溢出与进位

* 溢出表示超出了范围，已经不正确
* 进位超出范围，仍然正确

---

有符号无符号指的是最高位是否是符号位，即是以补码的形式看待还是以源码的形式看待

* CF：0~255 / 0X00~0XFF（8位）
  * 0~65536 / 0X0000~0XFFFF（16位）
* OF：-128~127 / 0X80~0XEF（8位）
  * -32768~32767 / 0X8000~0XEFFF（16位）

---

![image.png](https://i.loli.net/2020/07/19/U6dk17qWcSZnzPI.png)

#### 辅助进位标志

> 若运算时$D_{3}$（低半字节）有进位或借位时，AF = 1

#### 方向标志

> 用于串操作指令中，控制地址的变化方向
>
> * 设置DF为0，存储器地址自动增加
> * 设置DF为1，存储器地址自动减少
>
> For Example：
>
> * CLD 用于复位方向标志，执行后DF = 0
> * STD 用于置位方向标志，执行后DF = 1

#### 中断允许标志IF

> 用于控制外部可屏蔽中断是否可以被处理器响应
>
> * 设置IF 为0，禁止中断
> * 设置为1，允许中断
>
> For Example：
>
> * CLI 用于复位中断标志
> * STI 用于置位

#### 陷阱标志TF

> 用于控制处理器进入单步操作方式
>
> * 设置TF 为0，处理器正常工作
> * 设置TF为 1，处理器单步执行指令
>
> 单步执行指令：处理器在每条指令执行结束时，便产生一个编号为1的内部中断

## 指令简介

> 指令由操作码和操作数构成
>
> * 操作码：给出该指令应完成何种操作
> * 操作数：描述该指令的操作对象
>
> 操作码不可缺少，但是操作数可以没有，也可以有一个操作数或两个操作数

* 零操作数指令
  * 指令格式中没有操作数或操作数是隐含约定的
* 一操作数
  * 有一个或者还有一个隐含的双操作数
* 二操作数
  * 两个操作数【常见】
    * **目的操作数**
    * **源操作数**

由此，操作数分为目的操作数和源操作数

* 源操作数智能读取的操作数
* 目的操作数：可读取可写入（存放操作结果）的操作数

|  MOV   |     AX     |    10    |
| :----: | :--------: | :------: |
| 操作码 | 目的操作数 | 源操作数 |

## 寻址方式

> 指令中指明操作数存放位置的表达式

操作数的数据存放位置有三种情况：

1. 存放指令中（立即数）
   * 操作数包含在指令中，即被操作数据直接表示在指令的操作数字段中，也就是紧跟在操作码之后
     * MOV AL，10H
2. 存于寄存器中（寄存器操作数）
   * 数据存放在CPU的一个寄存器中
     * INC  CX
3. 存放于存储器中（存储器操作数）
   * 数据在内存中或在I/O端口中，存放数据的偏移地址以某种方式表示在指令中
     * MOV AX，[2500H] ，其中[2500] 为存储器操作数
     * 存储器操作数中操作数字段指示此操作数的偏移地址，而段地址由某个段寄存器来提供，此例中默认为数据段DS

### 立即数寻址方式

> 只允许源操作数为立即数，目标操作数必须是寄存器或存储器，其作用是给寄存器或存储单元赋值
>
> 汇编中，立即数不能作为指令中的第一操作数，也就是说不能MOV 80H，AL
>
> * MOV AL，80H
> * MOV AX，1234H

![image.png](https://i.loli.net/2020/07/19/JnNB8EQzRjxgG7Z.png)

### 寄存器寻址

> 表示格式：直接在指令中写出寄存器的名称
>
> * INC BX  BX中的数据自增1
> * MOV AX，CX   CX中的数据赋给AX

### 存储器寻址

> 直接在指令中写出寄存器名称
>
> * 直接寻址方式
> * 寄存器间接寻址方式
> * 寄存器相对寻址方式
> * 基址加变址寻址方式
> * 相对基址加变址寻址方式

**存储器有两种：内存和I/O端口**

#### 直接寻址

> 操作数存在内存中，操作数的偏移地址直接表示在指令中
>
> 表示格式：[偏移地址]
>
> 默认操作数存放在内存的数据段中
>
> * MOV AL，[1064H]

需要获取实际内存的数据，通过偏移地址获取内存的实际地址，借助段地址，默认存放在数据段中，所以数据段 x 10H + 偏移地址得到实际地址。

![image.png](https://i.loli.net/2020/07/19/H1dNFypzXU43MQL.png)

#### 段超越

* 操作数也允许存放在其他段中（ES，SS），此时应该在指令中指明段超越
* 若操作数不在指令默认的DS段中，而在其它某个段中，则需要在指令中加以表示，称为段超越
* 直接寻址方式中操作数在附加段中，应该表示为 MOV AL，ES：[1064H]

#### 寄存器间接寻址方式

> 操作数存在存储器中，操作数的偏移地址在BX、SI、DI、BP的某个寄存器中
>
> 若以BX、SI、DI作为间接寻址寄存器，则默认操作数存放在数据段中，用DS寄存器中的内容作为地址
>
> 若以BP作为间接寻址寄存器，则默认操作数存放在堆栈段中，用SS寄存器中的内容作为地址

![image.png](https://i.loli.net/2020/07/19/k1ED79RqawQv6Vx.png)

也存在段超越，若以BP作为间接寻址寄存器，则默认操作数存放在堆栈段中，用SS寄存器中的内容作为地址。

* MOV  AX，DS：[BP]
* MOV CH, SS: [SI]

#### 寄存器相对寻址方式

> 操作数在存储器中，操作数的有效地址是一个基址寄存器（BX、BP）或变址寄存器（SI、DI）的内容加上指令中给定的8位或16位位移量之和。
>
> 如果SI、DI、BX中的内容作为有效地址的一部分，那么引用的段寄存器是DS，如果BP中的内容作为有效地址的一部分，那么引用的段寄存器是 SS
>
> * 下面指令中，源操作数采用寄存器相对寻址，引用的段寄存器是SS：MOV BX，[BP - 4]
> * 下面的指令中，目的操作数采用寄存器相对寻址，引用段寄存器是ES：MOV ES：[BX+5]，AL
>
> 如： MOV CL，[BX+1064H]

![image.png](https://i.loli.net/2020/07/19/lV4aCcT8A3zeIpg.png)

#### 基址加变址寻址方式

通常把BX、BP看作是基址寄存器，把SI、DI看作变址寄存器，可把两种方式结合起来形成一种新的寻址方式

基址加变址的寻址方式是把一个基址寄存器BX或BP的内容，加上变址寄存器SI或DI的内容，并以一个段寄存器作为地址基准，作为操作数的地址。

如：MOV AH，[BP] [SI]

![image.png](https://i.loli.net/2020/07/19/bC9JaODEMiRq12m.png)

#### 相对基址加变址寻址方式

> 通常把BX、BP看作基址寄存器，SI、DI看作变址寄存器，把一个基址寄存器BX、BP的内容，加上变址寄存器SI、DI的内容，再加上指令中给定的8位或16位位移量，并以一个段寄存器作为地址基准，作为操作数的地址
>
> * 当基址寄存器为BX时，段寄存器使用DS
> * 当基址寄存器为BP时，段寄存器则用SS
>
> 如：MOV [BX+DI+1234H], [AH]

![image.png](https://i.loli.net/2020/07/19/tcFM38ls2zwnTrQ.png)

#### 总结

指令要有操作码，目的操作数，源操作数

## 数据传送指令

包括

* 通用传送指令
* 累加器专用传送指令
* 地址传送指令
* 标志传送指令

### 通用传送指令

#### 基本传送指令（MOV）

* 指令格式：MOV、DST、SRC
* 源操作数和目的操作数可用**前6种寻址方式的任何一种**
* 操作：将SRC内容赋给DST
* <font color="red">所有通用传送指令都不影响标志位</font>(前面提到的那9个标志位)

<font color="gree">注意：不能用MOV指令实现以下：</font>

* 存储器操作数之间不能直接传送

  * MOV [1000H], [DI]   (X)

  改为：

  * MOV  AX，[DI]      MOV  [1000H],  AX

* 立即数不能直接送段寄存器

  * MOV  DS,  2000H   (X)

  改为：

  * MOV  AX，2000H       MOV  DS，AX

* 段寄存器之间不能直接传送

  * MOV ES，DS  （X）

  改为：

  * MOV  AX，DS        MOV  ES，AX

* CS 只可以作为源操作数【<font color="red">CS：IP指向当前我们要执行的指令，如果更改了CS就会导致相关指令无法被执行</font>】

  * MOV  CS，AX   （X）

  改为：

  * MOV  AX，CS

* 源操作数和目的操作数的宽度必须相同

![image.png](https://i.loli.net/2020/07/19/2IEsgacjmBJOnA5.png)

#### 堆栈指令（PUSH、POP）

> 与SS、SP有关，SP永远指向栈顶

##### 入栈指令：PUSH  src

* (SP) <- (SP) - 2
* ((sp)+1,(sp))  <-  (src)

把一个字压入由SP指向的堆栈区

如：PUSH  AX

> 若（AX）=50A0H； SP = 2002H；SS = 6000H
>
> 执行PUSH  AX
>
> 再执行 PUSH  BX
>
> 设（BX） =  ABCDH
>
> ![image.png](https://i.loli.net/2020/07/19/YW19MKxvomjpOA2.png)

##### 出栈指令：POP  dst

* (dst)  <-  ((sp)+1, (sp))
* (SP)  <-  (SP) + 2

把 SP 所指向的堆栈顶部的一个字送入目的地址，同时进行修改堆栈指针

如：POP   BX    POP AX

堆栈的用途是存放中断

![](https://img-blog.csdnimg.cn/20200725090410541.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Jva29CYXNpbGlzaw==,size_16,color_FFFFFF,t_70)

* 存放寄存器或存储器中暂时不使用的数据，在使用这些数据时可以方便地将其弹出
* 调用子程序或发生中断时要保护断点信息（入栈），子程序或中断返回时恢复断点信息（出栈）

**注意的问题：**

* 堆栈操作都按字操作
* PUSH、POP指令的操作数可以是CPU内部寄存器或存储单元
* PUSH CS 合法，，POP CS 非法【CS不能随便修改，不能做操作数】
* 执行PUSH指令， (SP) -2  -> (SP)，低字节放在低地址，高字节放在高地址
* SP总指向栈顶；堆栈的最大容量即为SP初值与SS之差

##### 交换指令

XCHG  dst，src； （dst） < - >  (src)

可以实现寄存器之间、寄存器和存储器之间

**注意：**

* **存储器之间不能直接交换**
* 段寄存器不能作为操作数
* 允许字或字节操作

### 累加器专用传送指令

##### 输入指令（IN）

> 用于CPU从外设端口接收数据

* IN  AL, DATA8   从8位端口地址输入一个字节
* IN  AX, DATA8   从8位端口地址输入一个字
* IN  AL, DX         从16位端口地址输入一个字节
* IN  AX, DX         从16位端口地址输入一个字

##### 输出指令

> 用于CPU向外设端口发送数据

![image.png](https://i.loli.net/2020/07/19/vs1plDXPLT26rV5.png)

与输入指令一致

### 目的地址传送指令

> 8086提供三条
>
> * LEA
> * LDS
> * LES

<img src="https://i.loli.net/2020/07/19/bTnWrzR6jQUSNCP.png" alt="image.png" style="zoom:50%;" />

<img src="https://i.loli.net/2020/07/19/i3CPsvcV6EWIMYU.png" alt="image.png" style="zoom: 50%;" />

<img src="https://i.loli.net/2020/07/19/rjy2cetNdYKZTUi.png" alt="image.png" style="zoom:50%;" />

<img src="https://i.loli.net/2020/07/19/sgjNH69yl71Phrp.png" alt="image.png" style="zoom:50%;" />

LES 与 LDS 工作原理相同

### 标志传送指令

> 8086 有四种标志传送操作指令

<img src="https://i.loli.net/2020/07/19/FTkB3DJdI1wiZWs.png" alt="image.png" style="zoom:50%;" />

<img src="https://i.loli.net/2020/07/19/bzgtorvNEneyHp9.png" alt="image.png" style="zoom:50%;" />

<img src="https://i.loli.net/2020/07/19/U4eyJ8fl35HskhX.png" alt="image.png" style="zoom:50%;" />

## 算术运算指令（+ - x /）

### 加法指令

8086有5条加法指令：

* ADD 加法指令
* ADC 带进位加法指令
* INC 加 1 指令，自增 1 
* AAA 加法ASCII调整指令
* DAA 加法十进制调整指令

#### ADD 无进位加法指令

> ADD dest，src
>
> dest  <-  dest + src
>
> * src：立即数，通用寄存器，存储器
> * dest：通用寄存器，存储器
>
> <img src="https://i.loli.net/2020/07/19/VgP6rLhjfiXGBRo.png" alt="image.png" style="zoom:50%;" />

<img src="https://i.loli.net/2020/07/19/fCxnYvZAMDa3JUR.png" alt="image.png" style="zoom: 50%;" />

#### 带进位的ADC

> ADC dest，src
>
> dest <- dest + src + c
>
> C：进位标志C的现行值（上条指令C值）
>
> 特点与ADD相同，主要用于多字节运算中

![image.png](https://i.loli.net/2020/07/19/2JsPWolMTr1xL86.png)

#### 加1指令INC

> INC dest
>
> dest：通用寄存器、存储器
>
> 用于在循环程序中修改地址指针和循环次数
>
> 标志位影响情况，不影响进位 C

![image.png](https://i.loli.net/2020/07/19/27Nsj5ZyCmUEabB.png)

### 减法指令

* SUB 减法指令
* SBB 进位减法指令
* DEC 减 1 指令
* NEG 求补指令
* CMP 比较指令
* AAS 减法ASCII调整指令
* DAS 减法十进制调整指令

#### SUB无进位减法

> SUB dest，src
>
> src：立即数，通用寄存器、存储器
>
> dest：通用寄存器，存储器
>
> 指令影响标志位：A、C、O、P、S、Z

#### SBB 带进位减法

> SBB dest，src
>
> dest <- dest - src - C
>
> src：立即数，通用寄存器、存储器
>
> dest：通用寄存器、存储器

#### DEC

> DEC dest
>
> dest：通用寄存器、存储器，不能是段寄存器
>
> 用于循环修改地址指针和循环次数
>
> 不影响C

#### 求补指令 NEG

> NEG dest
>
> dest  <- 0-dest
>
> dest：通用寄存器、存储器
>
> 把操作数按位求反后末位 +1
>
> <img src="https://i.loli.net/2020/07/19/Wl4jsN632YbSxF1.png" alt="image.png" style="zoom:50%;" />

#### 比较指令CMP

> CMP dest，src
>
> dest - src   结果不保留，只是用来影响标志位A、C、O、P、S、Z
>
> src：立即数，通用寄存器，存储器
>
> dest：通用寄存器，存储器
>
> <img src="https://i.loli.net/2020/07/19/rjDuv26FoYTeMsd.png" alt="image.png" style="zoom:50%;" />

<img src="https://i.loli.net/2020/07/19/5kNgP3Z7LYfS4Jd.png" alt="image.png" style="zoom:50%;" />

通过标志位来判断。

### 乘法指令

#### 无符号乘法MUL

> NUL src
>
> 字节操作数：AX  <- （AL）*（SRC）
>
> 字操作数：DX：AX  <-  (AX)*(SRC)

#### 带符号乘法IMUL

> IMUL  SRC
>
> 同 MUL 的操作，但是操作数和乘积均带符号
>
> 按有符号数的规则相乘

### 除法指令

#### 无符号除法DIV

> DIV  SRC
>
> 字节除数：AL <- (AX)/(SRC)  之商
>
> ​						AH <- (AX)/(SRC) 之余数
>
> 字除数：AL  <- (DX:AX)/(SRC)  之商
>
> ​				  DX  <-  (DX:AX)/(SRC)  之余数

#### 带符号除法

> IDIV  SRC

商和余数都是带符号的，商的符号符合一般代数符号规则，余数的符号与被除数相同

![image.png](https://i.loli.net/2020/07/19/j4mNIEKLBq9CtAM.png)

![image.png](https://i.loli.net/2020/07/19/6FrHEsL2ukTaeZy.png)

## 逻辑运算和移位指令

### 逻辑运算

#### 测试指令

> TEST  dest，src
>
> SRC：立即数、通用寄存器、存储器
>
> dest：通用寄存器，存储器
>
> 规则同AND，操作数想与，结果不保存，用来改变标志位

#### 或指令OR

> dest、src不能同时为存储器操作数

#### 异或指令XOR

> 不能同时为存储器操作数
>
> dest：寄存器、存储器
>
> src：立即数、寄存器、存储器

#### 非NOT

> NOT  dest
>
> 操作数：寄存器、存储器，不能是立即数

### 移位指令

<img src="https://i.loli.net/2020/07/19/eh6v5O9P7qIdCTk.png" alt="image.png" style="zoom:50%;" />

![image.png](https://i.loli.net/2020/07/19/4irguqRUB9Xh7Wz.png)

> 移位等于 1 或者 CL，如果不是 1 ，尽量赋给 CL

#### 逻辑左移/算术左移SHL/SAL

> 实现相同的操作：
>
> > 相当于无符号数 * 2
>
> SHL 是逻辑左移，右边的位补零

#### 逻辑右移指令SHR

> 相当于无符号数 / 2
>
> > SHR 右移时，它的最高位用 0 填补，最低位移入 CF
> >
> > * SHR  BYTE  PTR[DI + BP], 1
> > * SHR  BL, 1
> > * SHR  AX, CL 

#### 算术右移指令SAR

> 和刚才的类似，**但是<font color="red">最高位不补零</font>**，最高位和移位前的最高位一致。
>
> SHR 右移时，最高位不变，最低位移入CF
>
> > MOV  AL, 88H
> >
> > MOV  AL, 2
> >
> > SAR  AL, CL
> >
> > RESULT :  AL = E2H

#### 不含进位标志循环左移指令ROL

> ROL 是循环左移，左边移出的位补到右边，并把这个值传给 CF

#### 不含C的循环右移指令ROR

> ROR类似于ROL，是循环右移，移出的位补到最左边，并且传给CF

#### 含C的循环左移指令RCL

> 循环左移，进位值（原CF）到低位，高位进CF
>
> > MOV  AL, 11110000B
> >
> > RCL  AL, 1
> >
> > 执行后AL = 11100000B  CF = 1

#### 含C的循环右移指令RCR

> 同RCL

![ULvr3d.png](https://s1.ax1x.com/2020/07/23/ULvr3d.png)

## 串操作指令

> 串：内存中一段地址相连的字节或字；串操作也叫数据块操作；可实现存储器数据间的直接传送
>
> > 8086 有5种基本串操作：
> >
> > MOVS  串传送指令
> >
> > CMPS  串比较指令
> >
> > SCAS  串扫描指令
> >
> > LODS  取串指令
> >
> > STOS  存串指令

讲 MOV 的时候说过存储器数据间不能直接传送，如果想要传递需要借助通用寄存器。

### MOVS B/W

> 串传送有2中格式：MOVSB / MOVSW

![UOCyvQ.png](https://s1.ax1x.com/2020/07/23/UOCyvQ.png)

![UOCHKJ.png](https://s1.ax1x.com/2020/07/23/UOCHKJ.png)

![UOPeG8.png](https://s1.ax1x.com/2020/07/23/UOPeG8.png)

 ![UOiFlF.png](https://s1.ax1x.com/2020/07/23/UOiFlF.png)

![UOiVm9.png](https://s1.ax1x.com/2020/07/23/UOiVm9.png)

**简化代码：**

![UOFl40.png](https://s1.ax1x.com/2020/07/23/UOFl40.png)

![UOFsgO.png](https://s1.ax1x.com/2020/07/23/UOFsgO.png)

### LODS

> 有两种格式：LODSB / LODSW

[![UOFo28.png](https://s1.ax1x.com/2020/07/23/UOFo28.png)](https://imgchr.com/i/UOFo28)

### STOS

> 两种格式：STOSB / STOSW

![UOZGnS.png](https://s1.ax1x.com/2020/07/23/UOZGnS.png)

### CMPS

> 结果不保存，只更改标志

![UOZahn.png](https://s1.ax1x.com/2020/07/23/UOZahn.png)

### SCAS

[![UOZh1x.png](https://s1.ax1x.com/2020/07/23/UOZh1x.png)](https://imgchr.com/i/UOZh1x)

### CMPS 和 SCAS 可与前缀 REPE / REPZ 和 REPNE / REPNZ 联合工作

> ①REPE / REPZ
>
> * 当相等/为零时重复串操作
>
> ②REPNE / REPNZ
>
> * 当不相等/不为零时重复串操作

## 程序控制指令

> 转移指令、循环控制指令、过程调用指令、中断指令

### 转移指令

> 控制程序（记得CS：IP吧）从一处转换到另一处执行，在 CPU 内部，转移是通过将**目标地址**传送给 **IP**实现
>
> 转移指令包括：
>
> * 无条件转移指令
> * 条件转移指令

#### 无条件转移指令 JMP

> JMP 语句标号
>
> JMP LP；

#### 条件转移指令

##### 根据单个条件标志转移

① Z标志

* JZ / JNZ
* z  --  zero

② C标志

* JC / JNC
* C -- 进位

③ P标志

* JP（JPE）/ JNP（JPO）
* 奇偶验证

④ S标志

* JS / JNS
* 负号跳转

⑤ O标志

* JO / JNO
* 溢出跳转

##### 根据两个无符号数大小关系转移

> JB （低于跳转）、JNAE；JNB、JAE
>
> JBE（不高于跳转）、JNA；JNBE、JA（高于跳转）

##### 根据两个带符号数比较结果转移

> JL（JNGE）/ JNL（JGE）: 小于跳转 / 不小于
>
> JLE（JNG）/ JNLE（JG）
>
> L - Less; G - Great; E - Equal
>
> 注意：所有条件转移指令都是段内（-128 ~ +127）范围内转移

### 过程（子程序）

> 子程序：程序中具有独立功能的部分编写成独立程序模块
>
> - 子程序调用   CALL  子过程名
> - 返回指令   RET  在子程序结尾，用来返回主程序

### 循环控制指令

#### 无条件循环

> LOOP  语句标号
>
> 执行操作：
>
> * （CX） <-   (CX)  - 1
> * 若CX ≠ 0，转向目标地址去执行，否则执行LOOP指令之后的指令
>
> 解释：遇到这条指令，首先执行CX = CX - 1；然后判断CX 的值，若 CX ！= 0，则转移到 Lable 处执行程序，否则向下继续执行

#### 条件循环

![UO7nyT.png](https://s1.ax1x.com/2020/07/23/UO7nyT.png)

[![UO73k9.png](https://s1.ax1x.com/2020/07/23/UO73k9.png)](https://imgchr.com/i/UO73k9)

### 中断指令

> * 中断调用：INT  n
>   * n   -    中断号：0 ~ 255
> * 中断返回 ：IRET

## 处理器控制类指令

### 标志处理指令

![UOH8Hg.png](https://s1.ax1x.com/2020/07/23/UOH8Hg.png)

![UOHIbD.png](https://s1.ax1x.com/2020/07/23/UOHIbD.png)